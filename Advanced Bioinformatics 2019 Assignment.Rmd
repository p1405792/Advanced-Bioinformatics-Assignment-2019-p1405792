---
title: "Advanced Bioinformatics 2019 Assignment"
author: "p1405792"
date: "03/05/2020"
output:
  github_document: default
  html_document: default
---

Task 1
```{r}
x <- seq(by=1, from=5, to=55); sum(x)
```
I used the x <- function to make x the sequence
The sequence used by=1 to ensure the sequence space meant that the values were all integers
By using from=5, to=55 the sequence was established as all integeres between 5 and 55
sum(x) then allowed for the sum of all the numbers in the sequence represented by x


Task 2
```{r}
sumfun <- function(n) {
  answer <- sum(seq(by=1, from=5, to=n))
return(answer)}
sumfun(10)
sumfun(20)
sumfun(100)
```
To create the sumfun function I made n the variable being used with the result of the function under the moniker answer
sumfun would then run the sum of a sequence of intergers (by=1) starting at 5 (from=5) until the sequence reached the variable n (to=n)
To get the answers I used the sumfun function where n=10, then n=20, then n=100


Task 3
```{r}
n <- 12
fib <- numeric(n)
fib[1] <- 1
fib[2] <- 1
for (i in 3:n)
{
  fib[i] <- fib[i-1]+fib[i-2]
}
fib
```
- by stating that n <- 12 when running fib you will get the first 12 numbers of the sequence
- the first 2 numbers are 1 so need to be set seperately to the rest of the for loop
- by using for (i in 3:n) you establish that the loop applys to integers between 3 and n
- fib[1] <- fib[i-1]+fib[i-2] establishes that each integer is the value of the previous two places in the sequence added together


Task 4
```{r}
library(ggplot2)
ggplot(data=mtcars,aes(x=gear, y=mpg, fill=gear)) + geom_bar(stat="identity")
```
Using dat=mtcars established mtcars as the data set that the values would be taken from
x=gear established the x axis as valued by the number gear
y=mpg established the y axis as valued by the mpg of the car
fill= gear established different colour fills on the bars differentiated by gear
geom_bar established the graph type as a bar graph
stat="identity" meant that the height of the bars were mapped to the value of the y axis at that location on the x axis


Task 5
```{r}
linearmodel <- lm(dist ~ speed, data=cars)
summary(linearmodel)
```
Intercept: -17.5791 Std Error: 6.7584
Slope: 3.9324 feet/mph  Std Error: 0.4155

I used dist as the y axis as it's the uncontrolled variable
Speed was used as the x axis as it was the controlled variable
data=cars was used to retrieve the data used


Task 6
```{r}
library(ggplot2)
ggplot(cars,aes(x=speed, y=dist)) + geom_point() + geom_smooth(method = lm, formula = y ~ x)
```
ggplot(cars,aes( allowed me to draw from the cars data for the plot
x=speed set car speed as the x axis as this was a controlled value
y=dist set breaking distance as the y axis as this was the uncontrolled value
geom_point() meant that the data was plotted in a scatter graph
geom_smooth added a straight line to the graph
method = lm allowed me to use the linear model to predict the line
function = y ~ x controlled the way that the lm function used the data


Task 7
```{r}
reactiontimemod <- lm(dist ~ I(speed^2)+0, data = cars)
summary(reactiontimemod)
x <- mean (residuals(reactiontimemod))
y <- mean (((cars$speed)/3600)*5280)
x/y
```
I created a lm that fitted the distance proportionally to the speed squared with an intercept of 0 (car isn't moving so should have no break distance)
Using this lm and the residuals to calculate a mean reaction distance which I labelled as x
I then used a mean value of the speed (diveded by 3600 and multiplyed by 5280 to convert the speed from mph to feet per second) of the driver which became y
x/y therefore is = to the reaction time
```{r}
library(ggplot2)
ggplot(cars,aes(x=speed, y=dist)) + geom_point() + geom_smooth(method = lm, formula = y ~ I(x^2) + 0)
```
